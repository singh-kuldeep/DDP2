\hypertarget{TVD_8cpp}{}\section{T\+V\+D.\+cpp File Reference}
\label{TVD_8cpp}\index{T\+V\+D.\+cpp@{T\+V\+D.\+cpp}}


This header file contains the run() function which runs the solver.  


{\ttfamily \#include \char`\"{}iostream\char`\"{}}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include \char`\"{}math.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}time.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}netfluxinterface.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}B\+C.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}initial\+\_\+condition.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}grid.\+h\char`\"{}}\\*
Include dependency graph for T\+V\+D.\+cpp\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{TVD_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{TVD_8cpp_aceceec12d8564f6adae5642b12db51fe}{BC} (vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&Conserved\+Variables, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&j\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&k\+Face\+Area\+Vector, int Ni, int Nj, int Nk)
\begin{DoxyCompactList}\small\item\em This function implements the boundary condition, i\+Face\+Area\+Vector is not required Because currently the flow in x direction and 2D flow. \end{DoxyCompactList}\item 
void \hyperlink{TVD_8cpp_a7d56149ed8fe8b17760b54f9bdffc052}{grid} (vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&i\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&j\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&k\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&Cell\+Volume, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&delta\+\_\+s, int \&Ni, int \&Nj, int \&Nk, int Geometry\+Option)
\begin{DoxyCompactList}\small\item\em This function generates the area vector and cell volumes inside the domain whole domain. \end{DoxyCompactList}\item 
int \hyperlink{TVD_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\begin{DoxyCompactList}\small\item\em This function runs the solver. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This header file contains the run() function which runs the solver. 

\begin{DoxyAuthor}{Author}
Kuldeep Singh 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
2017 
\end{DoxyDate}


\subsection{Function Documentation}
\index{T\+V\+D.\+cpp@{T\+V\+D.\+cpp}!BC@{BC}}
\index{BC@{BC}!T\+V\+D.\+cpp@{T\+V\+D.\+cpp}}
\subsubsection[{\texorpdfstring{B\+C(vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&\+Conserved\+Variables, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&j\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&k\+Face\+Area\+Vector, int Ni, int Nj, int Nk)}{BC(vector< vector< vector< vector< double > > > > &ConservedVariables, vector< vector< vector< vector< double > > > > &jFaceAreaVector, vector< vector< vector< vector< double > > > > &kFaceAreaVector, int Ni, int Nj, int Nk)}}]{\setlength{\rightskip}{0pt plus 5cm}void BC (
\begin{DoxyParamCaption}
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{Conserved\+Variables, }
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{j\+Face\+Area\+Vector, }
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{k\+Face\+Area\+Vector, }
\item[{int}]{Ni, }
\item[{int}]{Nj, }
\item[{int}]{Nk}
\end{DoxyParamCaption}
)}\hypertarget{TVD_8cpp_aceceec12d8564f6adae5642b12db51fe}{}\label{TVD_8cpp_aceceec12d8564f6adae5642b12db51fe}


This function implements the boundary condition, i\+Face\+Area\+Vector is not required Because currently the flow in x direction and 2D flow. 

This function implements the boundary condition, i\+Face\+Area\+Vector is not required Because currently the flow in x direction and 2D flow.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Conserved\+Variables} & This is the pointer to the 4D vector where all the conserved variables of previous time step are stored. \\
\hline
\mbox{\tt in}  & {\em \&i\+Face\+Area\+Vector} & This is a pointer to the 4D vector which has the area vector of all faces which are in \char`\"{}i\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em \&j\+Face\+Area\+Vector} & This is a pointer to the 4D vector which has the area vector of all faces which are in \char`\"{}j\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em \&k\+Face\+Area\+Vector} & This is a pointer to the 4D vector which has the area vector of all faces which are in \char`\"{}k\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em Ni} & Number of cells in in \char`\"{}i\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em Nj} & Number of cells in in \char`\"{}j\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em Nk} & Number of cells in in \char`\"{}k\char`\"{} direction. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
Inlet conditions are user given data. one has to mention the stagnation parameters at inlet (ex. stagnation pressure ( $ P_0 $), temperature( $ T_0 $))


\begin{DoxyParams}{Parameters}
{\em Temperature\+Stagnation} & Stagnation temperature at inlet\\
\hline
{\em Pressure\+Stagnation} & Stagnation pressure at inlet\\
\hline
{\em Density\+Stagnation} & Stagnation density at inlet\\
\hline
{\em theta} & Geometry rotation angle about the k (or z axis which is passing through origin) direction\\
\hline
{\em Inlet\+Angle} & Inlet upper wall angle\\
\hline
{\em Inlet\+Pressure} & Static pressure at inlet\\
\hline
{\em Mach} & Mach number at inlet\\
\hline
{\em Inlet\+Temperature} & Static temperature at inlet\\
\hline
{\em Inlet\+Velocity} & Flow velocity at inlet\\
\hline
{\em Inlet\+Density} & Flow density at inlet \\
\hline
\end{DoxyParams}
\index{T\+V\+D.\+cpp@{T\+V\+D.\+cpp}!grid@{grid}}
\index{grid@{grid}!T\+V\+D.\+cpp@{T\+V\+D.\+cpp}}
\subsubsection[{\texorpdfstring{grid(vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&i\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&j\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&k\+Face\+Area\+Vector, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&\+Cell\+Volume, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&delta\+\_\+s, int \&\+Ni, int \&\+Nj, int \&\+Nk, int Geometry\+Option)}{grid(vector< vector< vector< vector< double > > > > &iFaceAreaVector, vector< vector< vector< vector< double > > > > &jFaceAreaVector, vector< vector< vector< vector< double > > > > &kFaceAreaVector, vector< vector< vector< double > > > &CellVolume, vector< vector< vector< double > > > &delta_s, int &Ni, int &Nj, int &Nk, int GeometryOption)}}]{\setlength{\rightskip}{0pt plus 5cm}void grid (
\begin{DoxyParamCaption}
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{i\+Face\+Area\+Vector\+In, }
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{j\+Face\+Area\+Vector\+In, }
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{k\+Face\+Area\+Vector\+In, }
\item[{vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&}]{Cell\+Volume\+In, }
\item[{vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&}]{ds\+In, }
\item[{int \&}]{Ni, }
\item[{int \&}]{Nj, }
\item[{int \&}]{Nk, }
\item[{int}]{Geometry\+Option}
\end{DoxyParamCaption}
)}\hypertarget{TVD_8cpp_a7d56149ed8fe8b17760b54f9bdffc052}{}\label{TVD_8cpp_a7d56149ed8fe8b17760b54f9bdffc052}


This function generates the area vector and cell volumes inside the domain whole domain. 

This function generates the area vector and cell volumes inside the domain whole domain.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em i\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}i\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em j\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}j\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em k\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}k\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em Cell\+Volume\+In} & Input pointer to cell volumes \\
\hline
\mbox{\tt in}  & {\em ds\+In} & Input pointer to minimum distance \\
\hline
 & {\em Upper\+Coordinates} & Upper wall coordinates (x,y) of the nozzle geometry \\
\hline
 & {\em Down\+Coordinates} & Down wall coordinates (x,y) of the nozzle geometry /$\ast$$\ast$\\
\hline
\mbox{\tt in}  & {\em Ni} & Number of cells(\+Including ghost cells) in \char`\"{}i\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em Nj} & Number of cells(\+Including ghost cells) in \char`\"{}j\char`\"{} direction. \\
\hline
\mbox{\tt in}  & {\em Nk} & Number of cells(\+Including ghost cells) in \char`\"{}k\char`\"{} direction.\\
\hline
\end{DoxyParams}
This function generates the area vector and cell volumes inside the domain whole domain.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em i\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}i\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em j\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}j\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em k\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}k\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em Cell\+Volume\+In} & Input pointer to cell volumes \\
\hline
\mbox{\tt in}  & {\em ds\+In} & Input pointer to minimum distance \\
\hline
 & {\em Upper\+Coordinates} & Upper wall coordinates (x,y) of the nozzle geometry \\
\hline
 & {\em Down\+Coordinates} & Down wall coordinates (x,y) of the nozzle geometry \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em N+1} & Total \char`\"{}grid points\char`\"{} in j direction after including the boundary points\\
\hline
{\em N} & Total cells in j direction\\
\hline
\end{DoxyParams}
Only declaration is being done here initialization will be done in inside the individual geometry option


\begin{DoxyParams}{Parameters}
{\em Coordinate} & 4D vector which stores the all coordinates of all cells (Including ghost) inside the domain\\
\hline
{\em i\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}i\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
{\em j\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}j\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
{\em k\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}k\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
{\em Cell\+Volume} & 3D vector which stores the cell volume of all cells (Including ghost) inside the domain\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Do not change the Ni and Nj otherwise you will have to change the code for grid as well written inside the for loop below
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
 & {\em N+1} & Total \char`\"{}grid points\char`\"{} in j direction after including the boundary points\\
\hline
\mbox{\tt in}  & {\em Ni} & Number of cells(\+Including ghost cells) in \char`\"{}i\char`\"{} direction.\\
\hline
\mbox{\tt in}  & {\em Nj} & Number of cells(\+Including ghost cells) in \char`\"{}j\char`\"{} direction.\\
\hline
\mbox{\tt in}  & {\em Nk} & Number of cells(\+Including ghost cells) in \char`\"{}k\char`\"{} direction.\\
\hline
 & {\em (x0,y0)} & Live cell coordinates which needs to be mirrored to get the ghost cell coordinates\\
\hline
 & {\em (x1,y1)} & Next live cell coordinates which needs to be mirrored to get the ghost cell coordinates\\
\hline
 & {\em (l0,m0),(l1,m1)} & Line about which reflection needs to be taken\\
\hline
 & {\em (rx0,ry0)} & Ghost cell grid point\\
\hline
 & {\em (rx1,ry1)} & Ghost cell next grid point\\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000005}{Bug}]Yet to calculate the ds value properly \end{DoxyRefDesc}


Structure of grid out put file (\char`\"{}grids\+\_\+\+Nozzle\+\_\+2\+D.\+csv\char`\"{})
\begin{DoxyItemize}
\item First line of the grid file will contain grid points (excluding ghost cells) in x and y direction
\item This will exclude the ghost, only live cells or actual geomatry points
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
 & {\em N} & Total cells in j direction\\
\hline
 & {\em N+1} & Total \char`\"{}grid points\char`\"{} in j direction after including the boundary points\\
\hline
\mbox{\tt in}  & {\em Ni} & Number of cells(\+Including ghost cells) in \char`\"{}i\char`\"{} direction.\\
\hline
\mbox{\tt in}  & {\em Nj} & Number of cells(\+Including ghost cells) in \char`\"{}j\char`\"{} direction.\\
\hline
\mbox{\tt in}  & {\em Nk} & Number of cells(\+Including ghost cells) in \char`\"{}k\char`\"{} direction.\\
\hline
 & {\em Coordinate} & 4D vector which stores the all coordinates of all cells (Including ghost) inside the domain\\
\hline
 & {\em i\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}i\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
 & {\em j\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}j\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
 & {\em k\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}k\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
 & {\em Cell\+Volume} & 3D vector which stores the cell volume of all cells (Including ghost) inside the domain\\
\hline
 & {\em (x0,y0)} & Live cell coordinates which needs to be mirrored to get the ghost cell coordinates\\
\hline
 & {\em (x1,y1)} & Next live cell coordinates which needs to be mirrored to get the ghost cell coordinates\\
\hline
 & {\em (l0,m0),(l1,m1)} & Line about which reflection needs to be taken\\
\hline
 & {\em (rx0,ry0)} & Ghost cell grid point\\
\hline
 & {\em (rx1,ry1)} & Ghost cell next grid point\\
\hline
\end{DoxyParams}
Structure of grid out put file (\char`\"{}grids\+\_\+\+Nozzle\+\_\+2\+D.\+csv\char`\"{})
\begin{DoxyItemize}
\item First line of the grid file will contain grid points (excluding ghost cells) in x and y direction
\item This will exclude the ghost, only live cells or actual geomatry points
\end{DoxyItemize}\index{T\+V\+D.\+cpp@{T\+V\+D.\+cpp}!main@{main}}
\index{main@{main}!T\+V\+D.\+cpp@{T\+V\+D.\+cpp}}
\subsubsection[{\texorpdfstring{main()}{main()}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{TVD_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{}\label{TVD_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}


This function runs the solver. 

\begin{DoxyWarning}{Warning}
Currently not using this, because \hyperlink{TVD_8cpp_a7d56149ed8fe8b17760b54f9bdffc052}{grid()} is not calculating ds value properly. So recheck this function as well after fixing the \hyperlink{TVD_8cpp_a7d56149ed8fe8b17760b54f9bdffc052}{grid()} function. 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
double 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em Geometry\+Option} & Using this option the initial condition and the grids(area vector and the cell volumes will be defined appropriately)\\
\hline
{\em Start\+Time} & Simulation starting time\\
\hline
{\em End\+Time} & Simulation ending time\\
\hline
{\em DeltaT} & Time step\\
\hline
{\em Iteration\+Values} & Total iterations = floor(T\+I\+M\+E/\+DeltaT)\\
\hline
{\em Ni} & Number of cells(\+Including ghosts) in in \char`\"{}i\char`\"{} direction.\\
\hline
{\em Nj} & Number of cells(\+Including ghosts) in in \char`\"{}j\char`\"{} direction.\\
\hline
{\em Nk} & Number of cells(\+Including ghosts) in in \char`\"{}k\char`\"{} direction.\\
\hline
\end{DoxyParams}
Final value of the Ni,Nj,Nk has been decided inside the \hyperlink{TVD_8cpp_a7d56149ed8fe8b17760b54f9bdffc052}{grid()} function. So, do not use these parameters untill the grid function is callled


\begin{DoxyParams}{Parameters}
{\em \&i\+Face\+Area\+Vector} & This is a pointer to the 4D vector which has the area vector of all faces which are in \char`\"{}i\char`\"{} direction.\\
\hline
{\em \&j\+Face\+Area\+Vector} & This is a pointer to the 4D vector which has the area vector of all faces which are in \char`\"{}j\char`\"{} direction.\\
\hline
{\em \&k\+Face\+Area\+Vector} & This is a pointer to the 4D vector which has the area vector of all faces which are in \char`\"{}k\char`\"{} direction.\\
\hline
{\em Cell\+Volume\+In} & Input pointer to cell volumes\\
\hline
{\em delta\+\_\+s} & Minimum distance\\
\hline
{\em Conserved\+Variables} & This is the pointer to the 4D vector where all the conserved variables (\mbox{[}Density , x-\/momentum, y-\/momentum, z-\/momentum, Energy\mbox{]}) of previous time step are stored.\\
\hline
{\em Conserved\+Variables\+New} & This is the pointer to the 4D vector where all the conserved variables (\mbox{[}Density , x-\/momentum, y-\/momentum, z-\/momentum, Energy\mbox{]}) of current/new time step are stored.\\
\hline
{\em i\+Cell\+Interface\+Volume} & Average of right and left cell volume in i direction\\
\hline
{\em j\+Cell\+Interface\+Volume} & Average of right and left cell volume in j direction\\
\hline
{\em k\+Cell\+Interface\+Volume} & Average of right and left cell volume in k direction\\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000008}{Bug}]Local time step needs to be used to reduce the simulation time \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em Density\+Residual} & Density residual\\
\hline
{\em x\+Momentum\+Residual} & x Momentum residual\\
\hline
{\em y\+Momentum\+Residual} & y Momentum residual\\
\hline
{\em z\+Momentum\+Residual} & z Momentum residual\\
\hline
{\em Energy} & residual \\
\hline
\end{DoxyParams}
