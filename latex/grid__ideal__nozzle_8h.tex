\hypertarget{grid__ideal__nozzle_8h}{}\section{grid\+\_\+ideal\+\_\+nozzle.\+h File Reference}
\label{grid__ideal__nozzle_8h}\index{grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}}


This header file functions find the grid points, cell area vectors and the cell volumes for the ideal nozzle. In which nozzle has ans uniform flow at the exit. Because in the cancellation of expansion fan has been done by compression waves.  


{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include \char`\"{}math.\+h\char`\"{}}\\*
{\ttfamily \#include $<$fstream$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$cstdlib$>$}\\*
Include dependency graph for grid\+\_\+ideal\+\_\+nozzle.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{grid__ideal__nozzle_8h__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \hyperlink{grid__ideal__nozzle_8h_a49295397147e6ac59b00e1802fb652cf}{finddz} (std\+::vector$<$ std\+::vector$<$ double $>$ $>$ Down\+Coordinates)
\begin{DoxyCompactList}\small\item\em Find the cell side in z direction by taking average of all dx for dz. \end{DoxyCompactList}\item 
double \hyperlink{grid__ideal__nozzle_8h_adeaf7cb110880d4dc16735a6d3afdbf8}{distance} (std\+::vector$<$ double $>$ p1, std\+::vector$<$ double $>$ p2)
\begin{DoxyCompactList}\small\item\em Calculates the distance between the two points in 3D space. \end{DoxyCompactList}\item 
void \hyperlink{grid__ideal__nozzle_8h_a5864956dd2d7c0cd17af385ddab35597}{take\+Mirror} (double \&x, double \&y, double x1, double y1, double x2, double y2, double l, double m)
\begin{DoxyCompactList}\small\item\em This function will take boundary cell grid points and will calculate the ghost cell grid points by taking the mirror image about the boundary. \end{DoxyCompactList}\item 
void \hyperlink{grid__ideal__nozzle_8h_a0195a06d59a6445d9ef8d27b775caeb0}{grid} (vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&i\+Face\+Area\+Vector\+In, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&j\+Face\+Area\+Vector\+In, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&k\+Face\+Area\+Vector\+In, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&Cell\+Volume\+In, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&ds\+In, int \&Ni, int \&Nj, int \&Nk, int Geometry\+Option)
\begin{DoxyCompactList}\small\item\em This function calculates the cell area and the cell volumes of all cells including the ghost cells. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This header file functions find the grid points, cell area vectors and the cell volumes for the ideal nozzle. In which nozzle has ans uniform flow at the exit. Because in the cancellation of expansion fan has been done by compression waves. 

\begin{DoxyAuthor}{Author}
Kuldeep Singh 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
2017 
\end{DoxyDate}
\begin{DoxyWarning}{Warning}
For different geometries change this file accordingly. 
\end{DoxyWarning}


\subsection{Function Documentation}
\index{grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}!distance@{distance}}
\index{distance@{distance}!grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}}
\subsubsection[{\texorpdfstring{distance(std\+::vector$<$ double $>$ p1, std\+::vector$<$ double $>$ p2)}{distance(std::vector< double > p1, std::vector< double > p2)}}]{\setlength{\rightskip}{0pt plus 5cm}double distance (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ double $>$}]{p1, }
\item[{std\+::vector$<$ double $>$}]{p2}
\end{DoxyParamCaption}
)}\hypertarget{grid__ideal__nozzle_8h_adeaf7cb110880d4dc16735a6d3afdbf8}{}\label{grid__ideal__nozzle_8h_adeaf7cb110880d4dc16735a6d3afdbf8}


Calculates the distance between the two points in 3D space. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em p1} & First point. \\
\hline
\mbox{\tt in}  & {\em p2} & Second point. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Distance between the two points 
\end{DoxyReturn}
\index{grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}!finddz@{finddz}}
\index{finddz@{finddz}!grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}}
\subsubsection[{\texorpdfstring{finddz(std\+::vector$<$ std\+::vector$<$ double $>$ $>$ Down\+Coordinates)}{finddz(std::vector< std::vector< double > > DownCoordinates)}}]{\setlength{\rightskip}{0pt plus 5cm}double finddz (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ std\+::vector$<$ double $>$ $>$}]{Down\+Coordinates}
\end{DoxyParamCaption}
)}\hypertarget{grid__ideal__nozzle_8h_a49295397147e6ac59b00e1802fb652cf}{}\label{grid__ideal__nozzle_8h_a49295397147e6ac59b00e1802fb652cf}


Find the cell side in z direction by taking average of all dx for dz. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Down\+Coordinates} & (x,y)coordinates of the down wall of the nozzle. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double 
\end{DoxyReturn}
\index{grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}!grid@{grid}}
\index{grid@{grid}!grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}}
\subsubsection[{\texorpdfstring{grid(vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&i\+Face\+Area\+Vector\+In, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&j\+Face\+Area\+Vector\+In, vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&k\+Face\+Area\+Vector\+In, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&\+Cell\+Volume\+In, vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&ds\+In, int \&\+Ni, int \&\+Nj, int \&\+Nk, int Geometry\+Option)}{grid(vector< vector< vector< vector< double > > > > &iFaceAreaVectorIn, vector< vector< vector< vector< double > > > > &jFaceAreaVectorIn, vector< vector< vector< vector< double > > > > &kFaceAreaVectorIn, vector< vector< vector< double > > > &CellVolumeIn, vector< vector< vector< double > > > &dsIn, int &Ni, int &Nj, int &Nk, int GeometryOption)}}]{\setlength{\rightskip}{0pt plus 5cm}void grid (
\begin{DoxyParamCaption}
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{i\+Face\+Area\+Vector\+In, }
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{j\+Face\+Area\+Vector\+In, }
\item[{vector$<$ vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ $>$ \&}]{k\+Face\+Area\+Vector\+In, }
\item[{vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&}]{Cell\+Volume\+In, }
\item[{vector$<$ vector$<$ vector$<$ double $>$ $>$ $>$ \&}]{ds\+In, }
\item[{int \&}]{Ni, }
\item[{int \&}]{Nj, }
\item[{int \&}]{Nk, }
\item[{int}]{Geometry\+Option}
\end{DoxyParamCaption}
)}\hypertarget{grid__ideal__nozzle_8h_a0195a06d59a6445d9ef8d27b775caeb0}{}\label{grid__ideal__nozzle_8h_a0195a06d59a6445d9ef8d27b775caeb0}


This function calculates the cell area and the cell volumes of all cells including the ghost cells. 

This function generates the area vector and cell volumes inside the domain whole domain.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em i\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}i\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em j\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}j\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em k\+Face\+Area\+Vector\+In} & Input pointer to \char`\"{}k\char`\"{} faces area vector \\
\hline
\mbox{\tt in}  & {\em Cell\+Volume\+In} & Input pointer to cell volumes \\
\hline
\mbox{\tt in}  & {\em ds\+In} & Input pointer to minimum distance \\
\hline
 & {\em Upper\+Coordinates} & Upper wall coordinates (x,y) of the nozzle geometry \\
\hline
 & {\em Down\+Coordinates} & Down wall coordinates (x,y) of the nozzle geometry \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
 & {\em N} & Total cells in j direction\\
\hline
 & {\em N+1} & Total \char`\"{}grid points\char`\"{} in j direction after including the boundary points\\
\hline
\mbox{\tt in}  & {\em Ni} & Number of cells(\+Including ghost cells) in \char`\"{}i\char`\"{} direction.\\
\hline
\mbox{\tt in}  & {\em Nj} & Number of cells(\+Including ghost cells) in \char`\"{}j\char`\"{} direction.\\
\hline
\mbox{\tt in}  & {\em Nk} & Number of cells(\+Including ghost cells) in \char`\"{}k\char`\"{} direction.\\
\hline
 & {\em Coordinate} & 4D vector which stores the all coordinates of all cells (Including ghost) inside the domain\\
\hline
 & {\em i\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}i\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
 & {\em j\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}j\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
 & {\em k\+Face\+Area\+Vector} & 4D vector which stores the all \char`\"{}k\char`\"{} face area vectors of all cells(\+Including ghost) inside the domain\\
\hline
 & {\em Cell\+Volume} & 3D vector which stores the cell volume of all cells (Including ghost) inside the domain\\
\hline
 & {\em (x0,y0)} & Live cell coordinates which needs to be mirrored to get the ghost cell coordinates\\
\hline
 & {\em (x1,y1)} & Next live cell coordinates which needs to be mirrored to get the ghost cell coordinates\\
\hline
 & {\em (l0,m0),(l1,m1)} & Line about which reflection needs to be taken\\
\hline
 & {\em (rx0,ry0)} & Ghost cell grid point\\
\hline
 & {\em (rx1,ry1)} & Ghost cell next grid point\\
\hline
\end{DoxyParams}
Structure of grid out put file (\char`\"{}grids\+\_\+\+Nozzle\+\_\+2\+D.\+csv\char`\"{})
\begin{DoxyItemize}
\item First line of the grid file will contain grid points (excluding ghost cells) in x and y direction
\item This will exclude the ghost, only live cells or actual geomatry points
\end{DoxyItemize}\index{grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}!take\+Mirror@{take\+Mirror}}
\index{take\+Mirror@{take\+Mirror}!grid\+\_\+ideal\+\_\+nozzle.\+h@{grid\+\_\+ideal\+\_\+nozzle.\+h}}
\subsubsection[{\texorpdfstring{take\+Mirror(double \&x, double \&y, double x1, double y1, double x2, double y2, double l, double m)}{takeMirror(double &x, double &y, double x1, double y1, double x2, double y2, double l, double m)}}]{\setlength{\rightskip}{0pt plus 5cm}void take\+Mirror (
\begin{DoxyParamCaption}
\item[{double \&}]{x, }
\item[{double \&}]{y, }
\item[{double}]{x1, }
\item[{double}]{y1, }
\item[{double}]{x2, }
\item[{double}]{y2, }
\item[{double}]{l, }
\item[{double}]{m}
\end{DoxyParamCaption}
)}\hypertarget{grid__ideal__nozzle_8h_a5864956dd2d7c0cd17af385ddab35597}{}\label{grid__ideal__nozzle_8h_a5864956dd2d7c0cd17af385ddab35597}


This function will take boundary cell grid points and will calculate the ghost cell grid points by taking the mirror image about the boundary. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em \&x} & Pointer to x coordinate after taking mirror image \\
\hline
\mbox{\tt in}  & {\em \&y} & Pointer to y coordinate after taking mirror image \\
\hline
\mbox{\tt in}  & {\em l} & x coordinate of the point which is to mirrored \\
\hline
\mbox{\tt in}  & {\em m} & y coordinate of the point which is to mirrored \\
\hline
\mbox{\tt in}  & {\em (x1,y1)} & Starting point of the line about which mirror is taken \\
\hline
\mbox{\tt in}  & {\em (x2,y2)} & End point of the line about which mirror is taken \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
