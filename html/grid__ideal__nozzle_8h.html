<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Dual Degree Project: grid_ideal_nozzle.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dual Degree Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">grid_ideal_nozzle.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header file functions find the grid points, cell area vectors and the cell volumes for the ideal nozzle. In which nozzle has ans uniform flow at the exit. Because in the cancellation of expansion fan has been done by compression waves.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &quot;math.h&quot;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for grid_ideal_nozzle.h:</div>
<div class="dyncontent">
<div class="center"><img src="grid__ideal__nozzle_8h__incl.png" border="0" usemap="#grid__ideal__nozzle_8h" alt=""/></div>
<map name="grid__ideal__nozzle_8h" id="grid__ideal__nozzle_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="grid__ideal__nozzle_8h__dep__incl.png" border="0" usemap="#grid__ideal__nozzle_8hdep" alt=""/></div>
<map name="grid__ideal__nozzle_8hdep" id="grid__ideal__nozzle_8hdep">
<area shape="rect" id="node2" href="TVD_8cpp.html" title="This header file contains the run() function which runs the solver. " alt="" coords="35,80,109,107"/>
</map>
</div>
</div>
<p><a href="grid__ideal__nozzle_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49295397147e6ac59b00e1802fb652cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grid__ideal__nozzle_8h.html#a49295397147e6ac59b00e1802fb652cf">finddz</a> (std::vector&lt; std::vector&lt; double &gt; &gt; DownCoordinates)</td></tr>
<tr class="memdesc:a49295397147e6ac59b00e1802fb652cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the cell side in z direction by taking average of all dx for dz.  <a href="#a49295397147e6ac59b00e1802fb652cf">More...</a><br /></td></tr>
<tr class="separator:a49295397147e6ac59b00e1802fb652cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaf7cb110880d4dc16735a6d3afdbf8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grid__ideal__nozzle_8h.html#adeaf7cb110880d4dc16735a6d3afdbf8">distance</a> (std::vector&lt; double &gt; p1, std::vector&lt; double &gt; p2)</td></tr>
<tr class="memdesc:adeaf7cb110880d4dc16735a6d3afdbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between the two points in 3D space.  <a href="#adeaf7cb110880d4dc16735a6d3afdbf8">More...</a><br /></td></tr>
<tr class="separator:adeaf7cb110880d4dc16735a6d3afdbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5864956dd2d7c0cd17af385ddab35597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grid__ideal__nozzle_8h.html#a5864956dd2d7c0cd17af385ddab35597">takeMirror</a> (double &amp;x, double &amp;y, double x1, double y1, double x2, double y2, double l, double m)</td></tr>
<tr class="memdesc:a5864956dd2d7c0cd17af385ddab35597"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will take boundary cell grid points and will calculate the ghost cell grid points by taking the mirror image about the boundary.  <a href="#a5864956dd2d7c0cd17af385ddab35597">More...</a><br /></td></tr>
<tr class="separator:a5864956dd2d7c0cd17af385ddab35597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdf5cf168063009e847db46d6624c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grid__ideal__nozzle_8h.html#a6cdf5cf168063009e847db46d6624c1b">grid</a> (vector&lt; vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &gt; &amp;iFaceAreaVectorIn, vector&lt; vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &gt; &amp;jFaceAreaVectorIn, vector&lt; vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &gt; &amp;kFaceAreaVectorIn, vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &amp;CellVolumeIn, vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &amp;dsIn, int &amp;Ni, int &amp;Nj, int &amp;Nk)</td></tr>
<tr class="memdesc:a6cdf5cf168063009e847db46d6624c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the cell area and the cell volumes of all cells including the ghost cells.  <a href="#a6cdf5cf168063009e847db46d6624c1b">More...</a><br /></td></tr>
<tr class="separator:a6cdf5cf168063009e847db46d6624c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file functions find the grid points, cell area vectors and the cell volumes for the ideal nozzle. In which nozzle has ans uniform flow at the exit. Because in the cancellation of expansion fan has been done by compression waves. </p>
<dl class="section author"><dt>Author</dt><dd>Kuldeep Singh </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2017 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For different geometries change this file accordingly. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adeaf7cb110880d4dc16735a6d3afdbf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double distance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the distance between the two points in 3D space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>First point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>Second point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Distance between the two points </dd></dl>

</div>
</div>
<a class="anchor" id="a49295397147e6ac59b00e1802fb652cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double finddz </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>DownCoordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the cell side in z direction by taking average of all dx for dz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DownCoordinates</td><td>(x,y)coordinates of the down wall of the nozzle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a class="anchor" id="a6cdf5cf168063009e847db46d6624c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grid </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>iFaceAreaVectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>jFaceAreaVectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kFaceAreaVectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>CellVolumeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; double &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Nj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Nk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the cell area and the cell volumes of all cells including the ghost cells. </p>
<p>This function generates the area vector and cell volumes inside the domain whole domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iFaceAreaVectorIn</td><td>Input pointer to "i" faces area vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jFaceAreaVectorIn</td><td>Input pointer to "j" faces area vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kFaceAreaVectorIn</td><td>Input pointer to "k" faces area vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CellVolumeIn</td><td>Input pointer to cell volumes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dsIn</td><td>Input pointer to minimum distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">UpperCoordinates</td><td>Upper wall coordinates (x,y) of the nozzle geometry </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">DownCoordinates</td><td>Down wall coordinates (x,y) of the nozzle geometry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>Total cells in j direction</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N+1</td><td>Total grid points in j direction after including the boundary points</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ni</td><td>Input number of cells in in "i" direction.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nj</td><td>Input number of cells in in "j" direction.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nk</td><td>Input number of cells in in "k" direction.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Coordinate</td><td>4D vector which stores the all coordinates of all cells inside the domain</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iFaceAreaVector</td><td>4D vector which stores the all "i" face area vectors of all cells inside the domain</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">jFaceAreaVector</td><td>4D vector which stores the all "j" face area vectors of all cells inside the domain</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">kFaceAreaVector</td><td>4D vector which stores the all "k" face area vectors of all cells inside the domain</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">CellVolume</td><td>3D vector which stores the cell volume of all cells inside the domain</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">(x0,y0)</td><td>Live cell coordinates which needs to be mirrored to get the ghost cell coordinates</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">(x1,y1)</td><td>Next live cell coordinates which needs to be mirrored to get the ghost cell coordinates</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">(l0,m0),(l1,m1)</td><td>Line about which reflection needs to be taken</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">(rx0,ry0)</td><td>Ghost cell grid point</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">(rx1,ry1)</td><td>Ghost cell next grid point</td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>Yet to calculate the ds value properly </dd></dl>
<p>Structure of grid out put file ("grids_Nozzle_2D.csv")</p><ul>
<li>First line of the grid file will contain grid points (excluding ghost cells) in x and y direction</li>
<li>This will exclude the ghost, only live cells or actual geomatry points</li>
</ul>

</div>
</div>
<a class="anchor" id="a5864956dd2d7c0cd17af385ddab35597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void takeMirror </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will take boundary cell grid points and will calculate the ghost cell grid points by taking the mirror image about the boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">&amp;x</td><td>Pointer to x coordinate after taking mirror image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">&amp;y</td><td>Pointer to y coordinate after taking mirror image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>x coordinate of the point which is to mirrored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>y coordinate of the point which is to mirrored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">(x1,y1)</td><td>Starting point of the line about which mirror is taken </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">(x2,y2)</td><td>End point of the line about which mirror is taken </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
